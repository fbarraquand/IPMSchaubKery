---
title: "IPMs Chapitre 3"
author: "Tewann Beauchard"
date: "25/05/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Si l'on décide de s'intéresser aux modèles de population structurés en classes d'âges, il est primordial de prendre en compte le taux de croissance de la population (noté $\lambda_{t}$). C'est même la principale utilitée de ce type de modèle. De plus, ne pas négliger la densité dépendance, l'ajout de la stochasticité (variabilité) et les erreurs d'observations est tout aussi important pour obtenir une meilleure compréhension de la dynamique de la population étudiée.


```{r}
library(IPMbook)
#####
# 3.1 Introduction
# ================

# ~~~~ Create Figure 3.1 ~~~~
T <- 9                              # Number of years
N <- matrix(NA, nrow=T+1, ncol=3)   # Matrix to hold size of 3 populations
lambda <- c(0.5, 1, 1.4)            # Pop. growth rate of 3 pops
N[1,] <- 10                         # Initial population size is 10
for (t in 1:T){                     # Loop over years
  for (k in 1:3){                   # Loop over 3 populations
    N[t+1,k] <- lambda[k] * N[t,k]  # Project pop. one time step forward
  } #k
} #t

op <- par(cex=1.4)
plot(N[,1], type="l", ylim=range(N), ylab="Population size", xlab="Year", axes=FALSE, lwd=2.5)
lines(N[,2], lwd=2.5)
lines(N[,3], lwd=2.5)
axis(1, at=1:(T+1), labels=1:(T+1))
axis(2, las=1)
text(x=T, y=N[5,1], expression(paste(lambda, "=0.5")))
text(x=T, y=N[10,2] + 3, expression(paste(lambda, "=1.0")))
text(x=T, y=N[8,3], expression(paste(lambda, "=1.4")))
par(op)

# Schaub & Kéry (2022) Integrated Population Models
# Chapter 3 : Introduction to stage-structured population models
# ----------------------------------------------------
# Code from final MS.

# 3.2 Age- and stage-structured population models
# ===============================================

# 3.2.1 From a life-cycle graph to population equations
# -----------------------------------------------------

# ~~~~ Code for Fig. 3.3 ~~~~
sj <- 0.3      # Juvenile survival
sa <- 0.55     # Adult survival
f1 <- 1.3      # Number of female fledglings per 1-year old female and year
fa <- 1.8      # Number of female fledglings per adult female and year

N <- numeric(14)
N[1] <- 10
for (i in 2:14){
  if (i %% 2 == 0){   # even numbers
    N[i] <- N[i-1] / 2 * f1 + N[i-1] / 2 * fa
  } else {               # odd numbers
    N[i] <- N[i-2] * sa + N[i-1] * sj
  }
}
x <- c(rbind(1:7, 1:7 + 0.1))

plot(x=x, y=N, type="l", ylab="Total population size", ylim=c(7, 18),
     col="blue", lwd=2, axes=FALSE, xlab="Year")
axis(2, las=1)
axis(1)
points(x, N, pch=c(22, 1), cex=2, col=c("red", "darkgreen"), lwd=2)

```



```{r}

library(IPMbook) ; library(jagsUI)

# 3.3 Classical analysis of a matrix population model
# ===================================================

# 3.3.1 Analysis of a matrix population model without stochasticity
#       and parameter uncertainty
# -----------------------------------------------------------------

# Define the demographic rates
sj <- 0.55                                           # Juvenile survival
sa <- 0.3                                          # Adult survival
f1 <- 1.8                                           # Number of female fledglings per 1-year old female
fa <- 1.3                                           # Number of female fledglings per adult female

# Define the transition matrix A (inspired by woodchat shrike demography)
A <- matrix(c(f1 * sj, fa * sj, sa, sa), ncol=2, byrow=TRUE)
dimnames(A) <- list(c("1y", "ad"), c("1y", "ad"))
A                                                   # print the matrix

# Asymptotic population growth rate:
# ''''''''''''''''''''''''''''''''''

N1 <- c(10, 1)

T <- 7
N <- matrix(NA, nrow=2, ncol=T)                     # Population sizes
gr <- matrix(NA, nrow=3, ncol=T-1)                  # Growth rates
N[,1] <- N1
for (t in 2:T){
  N[,t] <- A %*% N[,t-1]
  gr[1,t-1] <- N[1,t] / N[1,t-1]
  gr[2,t-1] <- N[2,t] / N[2,t-1]
  gr[3,t-1] <- (N[1,t] + N[2,t]) / (N[1,t-1] + N[2,t-1])
}
sr <- N[1, ] / colSums(N)                           # State distribution (proportion of 1y)

# ~~~~ extra code for Figure 3.8 ~~~~
op <- par(las=1, "mfrow")
layout(matrix(1:3, 1, 3,byrow=TRUE), widths=c(1, 1, 1), heights=1, TRUE)
# Plot stage-specific population size
plot(N[1,], type="b", pch=16, ylim=range(c(min(N), colSums(N))), axes=FALSE,
     ylab="Population size", xlab="Time", col="red")
points(N[2,], type="b", pch=16, col="orange")
points(colSums(N), type="b", pch=16, col="blue")
axis(1)
axis(2)
mtext("A", at=1, line=0.5, cex=1.5)
legend("bottomright", legend=c("1y", "ad", "total"), bty="n", pch=rep(16, 3),
       lty=rep(1, 3), col=c("red", "orange", "blue"))

# Plot stage-specific growth rates
plot(x=(1:(T-1)) + 0.5, y=gr[1,], type="b", pch=16, ylim=range(gr),
     xlim=c(1, T), axes=FALSE, ylab="Population growth rate", xlab="Time", col="red")
points(x=(1:(T-1)) + 0.5, y=gr[2,], type="b", pch=16, col="orange")
points(x=(1:(T-1)) + 0.5, y=gr[3,], type="b", pch=16, col="blue")
axis(1, at=1:T, labels=1:T)
axis(2)
abline(h=max(Re(eigen(A)$values)), lty=2)
mtext("B", at=1, line=0.5, cex=1.5)

# Plot actual stage distribution
plot(sr, type="b", pch=16, ylab="Proportion of stage classes", axes=FALSE,
     col="red", xlab="Time", ylim=range(c(sr, 1-sr)))
points(1-sr, type="b", pch=16, col="orange")
axis(1)
axis(2)
u <- which.max(Re(eigen(A)$values))
revec <- Re(eigen(A)$vectors[,u])
abline(h=revec[1]/sum(revec), col="red", lty=2)
abline(h=revec[2]/sum(revec), col="orange", lty=2)
mtext("C", at=1, line=0.5, cex=1.5)
par(op)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```
Modifier de quelques dixièmes la survie des individus a plus d'impact sur la taille de population par stades qu'une modification de la fécondité/productivité.


```{r}

# Compute asymptotic population growth rate (lambda)
lambda <- max(Re(eigen(A)$values))

# ~~~~ extra code for Figure 3.9 ~~~~
# Define the demographic rates
s1 <- 0.5     # Juvenile survival
s2 <- 0.8     # 1y survival
s3 <- 0.9     # Ad survival
rho1 <- 0.5   # Productivity of 2-years old females
rho2 <- 0.9   # Productivity of adult females

# Define the transition matrix A
Abat <- matrix(c(0, rho1*s1/2, rho2*s1/2,
                 s2, 0, 0,
                 0, s3, s3), ncol=3, byrow=TRUE)

# Define R structures and do computations
T <- 9
N1 <- c(10, 5, 5)                   # Initial population sizes
N <- matrix(NA, nrow=3, ncol=T)     # Population size
gr <- matrix(NA, nrow=4, ncol=T-1)  # Growth rate
N[,1] <- N1
for (t in 2:T){
  N[,t] <- Abat %*% N[,t-1]  # stage-specific population sizes
  gr[1,t-1] <- N[1,t] / N[1,t-1]
  gr[2,t-1] <- N[2,t] / N[2,t-1]
  gr[3,t-1] <- N[3,t] / N[3,t-1]
  gr[4,t-1] <- (N[1,t] + N[2,t] + N[3,t]) / (N[1,t-1] + N[2,t-1] + N[3,t-1])
}
sr <- sweep(N, 2, colSums(N), "/")   # Stage distribution

# Plots
co <- c("red", "orange", "tomato2")
op <- par(las=1, cex=1.1, "mfrow")
layout(matrix(1:3, 1, 3, byrow=TRUE), widths=c(1, 1, 1), heights=1, TRUE)
plot(N[1,], type="b", pch=16, ylim=range(c(min(N), colSums(N))), axes=FALSE,
     ylab="Population size", xlab="Time", col=co[1])
points(N[2,], type="b", pch=16, col=co[2])
points(N[3,], type="b", pch=16, col=co[3])
points(colSums(N), type="b", pch=16, col="blue")
axis(1, at=1:T)
axis(2)
mtext("A", at=1, line=0.5, cex=1.5)

plot(x=(1:(T-1)) + 0.5, y=gr[1,], type="b", pch=16, ylim=range(gr), xlim=c(1, T),
     axes=FALSE, ylab="Population growth rate", xlab="Time", col=co[1])
points(x=(1:(T-1)) + 0.5, y=gr[2,], type="b", pch=16, col=co[2])
points(x=(1:(T-1)) + 0.5, y=gr[3,], type="b", pch=16, col=co[3])
points(x=(1:(T-1)) + 0.5, y=gr[4,], type="b", pch=16, col="blue")
axis(1, at=1:T)
axis(2)
abline(h=max(Re(eigen(Abat)$values)), lty=2)
mtext("B", at=1, line=0.5, cex=1.5)
legend("topright", legend=c("1y", "2y", "ad", "total"), bty="n", pch=rep(16,4),
       lty=rep(1, 4), col=c(co, "blue"))

plot(sr[1,], type="b", pch=16, ylab="Proportion of stage classes", axes=FALSE,
     col=co[1], ylim=c(0, 0.8), xlab="Time")
points(sr[2,], type="b", pch=16, col=co[2])
points(sr[3,], type="b", pch=16, col=co[3])
axis(1, at=1:T)
axis(2)
u <- which.max(Re(eigen(Abat)$values))
revec <- Re(eigen(Abat)$vectors[,u])
abline(h=revec[1]/sum(revec), col=co[1], lty=2)
abline(h=revec[2]/sum(revec), col=co[2], lty=2)
abline(h=revec[3]/sum(revec), col=co[3], lty=2)
mtext("C", at=1, line=0.5, cex=1.5)
par(op)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Stable stage distribution:
# ''''''''''''''''''''''''''

u <- which.max(Re(eigen(A)$values))

revec <- Re(eigen(A)$vectors[,u])

revec/sum(revec)


# Stage-specific reproductive values:
# '''''''''''''''''''''''''''''''''''

u <- which.max(Re(eigen(A)$values))
levec <- Re((eigen(A)$vectors)[u,])
levec / sum(levec)


# Net reproductive rate:
# ''''''''''''''''''''''

i <- 1:100                                          # 100 as our approximation to infinity
R0 <- sj * f1 + sj * fa * sum(sa^i)


# Generation time
# '''''''''''''''

Q <- 100                                            # Our approximation to infinity
i <- 2:Q
G <- sj * f1 / lambda + sj * fa * sum(i * sa^(i-1) * lambda^(-i))


GT <- log(R0) / log(lambda)


```
